use std::collections::{HashMap, HashSet};
use specs;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Model {
  pub vertices: Vec<(f32, f32, f32)>,
  pub indices: Vec<u16>,
}

impl Model {
  pub fn dummy() -> Model {
    Model {
      vertices: vec![
        (-1.0, -1.0,  1.0),
        ( 1.0, -1.0,  1.0),
        ( 1.0,  1.0,  1.0),
        (-1.0,  1.0,  1.0),
        // Bottom
        (-1.0,  1.0, -1.0),
        ( 1.0,  1.0, -1.0),
        ( 1.0, -1.0, -1.0),
        (-1.0, -1.0, -1.0),
        // Right
        ( 1.0, -1.0, -1.0),
        ( 1.0,  1.0, -1.0),
        ( 1.0,  1.0,  1.0),
        ( 1.0, -1.0,  1.0),
        // Left
        (-1.0, -1.0,  1.0),
        (-1.0,  1.0,  1.0),
        (-1.0,  1.0, -1.0),
        (-1.0, -1.0, -1.0),
        // Front
        ( 1.0,  1.0, -1.0),
        (-1.0,  1.0, -1.0),
        (-1.0,  1.0,  1.0),
        ( 1.0,  1.0,  1.0),
        // Back
        ( 1.0, -1.0,  1.0),
        (-1.0, -1.0,  1.0),
        (-1.0, -1.0, -1.0),
        ( 1.0, -1.0, -1.0),
      ],
      indices: vec![
         0,  1,  2,  2,  3,  0, // top
         4,  5,  6,  6,  7,  4, // bottom
         8,  9, 10, 10, 11,  8, // right
        12, 13, 14, 14, 15, 12, // left
        16, 17, 18, 18, 19, 16, // front
        20, 21, 22, 22, 23, 20, // back
      ]
    }
  }
}


/**
 * Contains all of the state for world objects that the client needs.
 *
 * A lower fidelity version of the ServerWorld.
 */
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ClientWorld {
  pub own_entity: Option<Entity>,
  pub entities: Vec<Entity>,
  pub rendered: HashMap<Entity, RenderAspect>,
  pub physical: HashMap<Entity, PhysicalAspect>,
  pub disabled: HashSet<Entity>
}

pub type Entity = String;

/**
 * An aspect for an entity that can be rendered by a Renderer.
 *
 * Contains the details needed to render it.
 *
 * Most entities implementing RenderAspect also implement PhysicalAspect in order to be rendered
 * somewhere besides the origin of the scene.
 */
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct RenderAspect {
  pub model: Model
}

impl RenderAspect {
  pub fn new() -> RenderAspect {
    RenderAspect { model: Model::dummy() }
  }
}

impl specs::Component for RenderAspect {
  type Storage = specs::VecStorage<RenderAspect>;
}

/**
 * An aspect for an entity that has a physical presense in the scene
 *
 * Contains the physical location and whether the entity is mobile or not
 */
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PhysicalAspect {
  pub pos: (f32, f32, f32),
  pub vel: (f32, f32, f32),
  pub ang: (f32, f32, f32),
  pub ang_vel: (f32, f32, f32),
  pub anchored: bool
}

impl PhysicalAspect{
  pub fn new(pos: (f32, f32, f32), vel: (f32, f32, f32), anchored: bool) -> PhysicalAspect {
    PhysicalAspect { pos: pos, vel: vel, ang: (0.0, 0.0, 0.0), ang_vel: (0.0, 0.0, 0.0), anchored: anchored }
  }
}

impl specs::Component for PhysicalAspect {
  type Storage = specs::VecStorage<PhysicalAspect>;
}

#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct DisabledAspect;

impl DisabledAspect {
  pub fn new() -> DisabledAspect {
    DisabledAspect
  }
}

impl specs::Component for DisabledAspect {
  type Storage = specs::HashMapStorage<DisabledAspect>;
}
