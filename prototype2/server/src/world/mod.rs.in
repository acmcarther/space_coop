use time::{self, Tm};

use common::network;
use common::model::ModelType;
use common::world::{
  RenderAspect,
  PhysicalAspect,
  DisabledAspect,
  SynchronizedAspect,
};
use common::protocol::ClientPayload;
use protocol::OutboundEvent;

use specs;
use engine;

pub struct ServerWorld {
  pub world: specs::World,
}

impl ServerWorld {
  pub fn new() -> ServerWorld {
    let mut w = specs::World::new();

    w.register::<RenderAspect>();
    w.register::<CollisionAspect>();
    w.register::<PhysicalAspect>();
    w.register::<DisabledAspect>();
    w.register::<PlayerAspect>();
    w.register::<ControllerAspect>();
    w.register::<SynchronizedAspect>();
    // TODO(acmcarther): put these where they belong (like in the service that needs them?)
    // also check that the type isn't already taken
    // Networking ///////////////////////////////////
    w.add_resource::<Vec<OutboundEvent>>(Vec::new());
    w.add_resource::<Vec<ClientPayload>>(Vec::new());
    // Eventing ////////////////////////////////////
    w.add_resource::<Vec<engine::player::connection::ConnectEvent>>(Vec::new());
    w.add_resource::<Vec<engine::player::snapshot::SnapshotAckEvent>>(Vec::new());
    w.add_resource::<Vec<engine::player::input::InputEvent>>(Vec::new());
    w.add_resource::<Vec<engine::io::health_check::HealthyEvent>>(Vec::new());
    ServerWorld { world: w }
  }
}

/**
 * An aspect for an entity representing a player.
 *
 * Contains the player's network information.
 */
#[derive(Debug, Clone)]
pub struct PlayerAspect {
  pub address: network::Address,
  pub last_msg: Tm,
  pub connected: bool,
}

impl PlayerAspect {
  pub fn new(address: network::Address, connected: bool) -> PlayerAspect {
    PlayerAspect { address: address, last_msg: time::now(), connected: connected }
  }
}

impl specs::Component for PlayerAspect {
  type Storage = specs::HashMapStorage<PlayerAspect>;
}

/**
 * An aspect for an entity that "possesses" another entity.
 *
 * Contains a reference to that other entity in question.
 *
 * Players are common implementors -- they can possess a world object and control it.
 */
#[derive(Debug, Clone)]
pub struct ControllerAspect {
  pub subject: SynchronizedAspect,
}

impl ControllerAspect {
  pub fn new(subject: SynchronizedAspect) -> ControllerAspect {
    ControllerAspect { subject: subject }
  }
}

impl specs::Component for ControllerAspect {
  type Storage = specs::HashMapStorage<ControllerAspect>;
}

/**
 * An aspect for an entity that can be collided with
 *
 * Contains the collision model to be checked against
 */
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct CollisionAspect {
  pub model: ModelType
}

impl CollisionAspect{
  pub fn new() -> CollisionAspect {
    CollisionAspect { model: ModelType::Cube }
  }

  pub fn from_render(render: &RenderAspect) -> CollisionAspect {
    CollisionAspect { model: render.model.clone() }
  }
}

impl specs::Component for CollisionAspect {
  type Storage = specs::VecStorage<CollisionAspect>;
}
