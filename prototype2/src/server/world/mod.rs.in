use std::collections::HashMap;

use uuid::Uuid;
use common::network;
use common::world::{
  Entity,
  RenderAspect,
  ClientWorld,
  PhysicalAspect,
};

use std::net::SocketAddr;

// A trait for Views to depend on
pub trait WorldContainer {
  fn world(&self) -> &ServerWorld;
  fn mut_world(&mut self) -> &mut ServerWorld;
}

impl WorldContainer for ServerWorld {
  fn world(&self) -> &ServerWorld {
    self
  }

  fn mut_world(&mut self) -> &mut ServerWorld {
    self
  }
}

// A high fidelity version of the client world
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ServerWorld {
  pub addr_to_player: HashMap<network::Address, Uuid>,
  pub players: HashMap<Uuid, Player>,
  pub entities: Vec<Entity>,
  pub rendered: HashMap<Entity, RenderAspect>,
  pub physical: HashMap<Entity, PhysicalAspect>,
  pub controlled: HashMap<Entity, ControlledAspect>,
  pub controlled_inverse: HashMap<Uuid, ControlledAspect>
}

impl ServerWorld {
  pub fn new() -> ServerWorld {
    ServerWorld {
      addr_to_player: HashMap::new(),
      players: HashMap::new(),
      entities: Vec::new(),
      rendered: HashMap::new(),
      physical: HashMap::new(),
      controlled: HashMap::new(),
      controlled_inverse: HashMap::new()
    }
  }

  pub fn as_client_world(&self) -> ClientWorld {
    ClientWorld {
      entities: self.entities.clone(),
      rendered: self.rendered.clone(),
      physical: self.physical.clone(),
    }
  }

  pub fn all_connected_addrs(&self) -> Vec<SocketAddr> {
    self.players.values()
      .filter(|p| p.connected)
      .map(|p| p.address.clone())
      .collect()
  }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Player {
  uuid: Uuid,
  address: network::Address,
  connected: bool
}

impl Player {
  pub fn new(addr: network::Address) -> Player {
    Player {
      uuid: Uuid::new_v4(),
      address: addr,
      connected: false,
    }
  }

  pub fn address(&self) -> &network::Address {
    &self.address
  }

  pub fn set_connected(&mut self, connected: bool) {
    self.connected = connected
  }

  pub fn uuid(&self) -> &Uuid {
    &self.uuid
  }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ControlledAspect {
  pub uuid: Uuid
}

impl ControlledAspect {
  pub fn new(uuid: Uuid) -> ControlledAspect {
    ControlledAspect { uuid: uuid }
  }
}

