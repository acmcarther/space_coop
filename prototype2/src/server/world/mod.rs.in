use std::collections::{HashMap, HashSet};

use uuid::Uuid;
use time::{self, Tm};

use common::network;
use common::world::{
  Entity,
  RenderAspect,
  PhysicalAspect,
};

/**
 * A trait for Views to depend on
 * TODO(acmcarther): Why?
 */
pub trait WorldContainer {
  fn world(&self) -> &ServerWorld;
  fn mut_world(&mut self) -> &mut ServerWorld;
}

impl WorldContainer for ServerWorld {
  fn world(&self) -> &ServerWorld { self }
  fn mut_world(&mut self) -> &mut ServerWorld { self }
}

/**
 * Contains all of the state for world objects.
 *
 * A high fidelity version of the ClientWorld
 */
#[derive(Debug, Clone)]
pub struct ServerWorld {
  // Supplemental state for efficient access
  pub addr_to_player: HashMap<network::Address, Uuid>,

  // Conventional world state
  pub entities: Vec<Entity>,
  pub rendered: HashMap<Entity, RenderAspect>,
  pub physical: HashMap<Entity, PhysicalAspect>,
  pub disabled: HashSet<Entity>,
  pub player: HashMap<Entity, PlayerAspect>,
  pub controller: HashMap<Entity, ControllerAspect>
}

impl ServerWorld {
  pub fn new() -> ServerWorld {
    ServerWorld {
      // Supplemental state for efficient access
      addr_to_player: HashMap::new(),

      // Conventional world state
      entities: Vec::new(),
      rendered: HashMap::new(),
      physical: HashMap::new(),
      disabled: HashSet::new(),
      controller: HashMap::new(),
      player: HashMap::new()
    }
  }
}

/**
 * An aspect for an entity representing a player.
 *
 * Contains the player's network information.
 */
#[derive(Debug, Clone)]
pub struct PlayerAspect {
  pub address: network::Address,
  pub last_msg: Tm,
  pub connected: bool,
}

impl PlayerAspect {
  pub fn new(address: network::Address, connected: bool) -> PlayerAspect {
    PlayerAspect { address: address, last_msg: time::now(), connected: connected }
  }
}

/**
 * An aspect for an entity that "possesses" another entity.
 *
 * Contains a reference to that other entity in question.
 *
 * Players are common implementors -- they can possess a world object and control it.
 */
#[derive(Debug, Clone)]
pub struct ControllerAspect {
  pub subject: Entity,
}

impl ControllerAspect {
  pub fn new(subject: Entity) -> ControllerAspect {
    ControllerAspect { subject: subject }
  }
}
