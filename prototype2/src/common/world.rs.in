use std::collections::{HashMap, HashSet};

use uuid::Uuid;

/**
 * Contains all of the state for world objects that the client needs.
 *
 * A lower fidelity version of the ServerWorld.
 */
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ClientWorld {
  pub own_entity: Option<Entity>,
  pub entities: Vec<Entity>,
  pub rendered: HashMap<Entity, RenderAspect>,
  pub physical: HashMap<Entity, PhysicalAspect>,
  pub disabled: HashSet<Entity>
}

pub type Entity = Uuid;

/**
 * An aspect for an entity that can be rendered by a Renderer.
 *
 * Contains the details needed to render it.
 *
 * Most entities implementing RenderAspect also implement PhysicalAspect in order to be rendered
 * somewhere besides the origin of the scene.
 */
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct RenderAspect {
  pub model: String
}

impl RenderAspect {
  pub fn new() -> RenderAspect {
    RenderAspect { model: "dummy".to_owned() }
  }
}

/**
 * An aspect for an entity that has a physical presense in the scene
 *
 * Contains the physical location and whether the entity is mobile or not
 */
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PhysicalAspect {
  pub pos: (f32, f32, f32),
  pub vel: (f32, f32, f32),
  pub anchored: bool
}

impl PhysicalAspect{
  pub fn new(pos: (f32, f32, f32), vel: (f32, f32, f32), anchored: bool) -> PhysicalAspect {
    PhysicalAspect { pos: pos, vel: vel, anchored: anchored }
  }
}

